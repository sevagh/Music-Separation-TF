function outputFilenames = extractDistortionComponents(...
    srcFiles,estFile,options)
% Decomposition of an estimated source (or source image) into
%      the true target
%      + the target distortion (spatially-distorted and filtered version
%      of the target)
%      + the interference distortion component (spatially-distorted and
%      filtered version of other sources)
%      + the artifact and noise component
%
% Usage:
%
%   - outputFilenames = extractDistortionComponents(srcFiles,estFile)
% 
%   - outputFilenames = extractDistortionComponents(srcFiles,estFile,options)
%
% Inputs:
%   srcFiles is a cell array with the file names related to the
%   true sources (the target source is the first one), estFile is a string.
%   Signals must be stored in .wav files.
%
% Outputs:
%   the file names of the resulting sounds are returned as a cell array in
%   outputFilenames.
%
% Optional input:
%      options.destDir (default: './'): output directory where distortion
%       component .wav files are written.
%      options.segmentationFactor (default: 1): the signals are splitted in
%      options.segmentationFactor parts which are processed successively
%       and finally merged with an overlap-add method. Increase this number
%       when experiencing Out of Memory issues.
%      options.frameLength (default: .5): frame length, in seconds, for the
%       1kHz band, for the time vaying analysis. The frame length in
%       other bands is derived from this parameter and is proportional to
%       the bandwith.
%      options.filterLength (default: .04): filter length, in seconds, for
%       the 1kHz band, for the allowed filtering distortions. The filter
%       length in other bands is derived from this parameter and is
%       proportional to the bandwith.
%      options.shadeInMs (default: 10): when nonnegative, this number is
%       the length, in ms, of half a hanning window used to insert a shade
%       in.
%      options.shadeOutMs (default: 10) when nonnegative, this number is
%       the length, in ms, of half a hanning window used to insert a shade
%       out.
%      options.tmpDir (default: system default temporary directory):
%       directory where temporary files are written.
%      options.outputFilenames (default: []): filenames of the distortion 
%      components generated by the method.
%      options.FLAG_2PROJ (default: false): boolean flag to use two
%       least square projections (true) or only one (false).
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Version history
%  - Version 1.0.1, September 2011: added error in case sound files have
%  different sizes
%  - Version 1.0, June 2010: first release
% Copyright 2010-2011 Valentin Emiya (INRIA).
% This software is distributed under the terms of the GNU Public License
% version 3 (http://www.gnu.org/licenses/gpl.txt).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


if nargin<2
    error('extractDistortionComponents:notEnoughArguments','Not enough arguments');
end

defaultOptions.destDir = './';
defaultOptions.tmpDir = tempdir;
defaultOptions.outputFilenames = [];
defaultOptions.GR = false;
defaultOptions.FLAG_2PROJ = false;
defaultOptions.frameLength = .5;
defaultOptions.filterLength = .04;
defaultOptions.segmentationFactor = 1;
defaultOptions.shadeInMs = 10;
defaultOptions.shadeOutMs = 10;

if nargin<3
    options = defaultOptions;
else
    names = fieldnames(defaultOptions);
    for k=1:length(names)
        if ~isfield(options,names{k}) || isempty(options.(names{k}))
            options.(names{k}) = defaultOptions.(names{k});
        end
    end
end

destDir = options.destDir;

J = length(srcFiles);

if isempty(options.outputFilenames)
    outputFilenames = cell(4,1);
    [dum filename] = fileparts(estFile);
    outputFilenames{1} = [destDir filename '_true.wav'];
    outputFilenames{2} = [destDir filename '_eTarget.wav'];
    outputFilenames{3} = [destDir filename '_eInterf.wav'];
    outputFilenames{4} = [destDir filename '_eArtif.wav'];
    options.outputFilenames = outputFilenames;
else
    outputFilenames = options.outputFilenames;
end

if options.segmentationFactor>1
    aux_segmentAndDecompose(srcFiles,estFile,options);
    return
end

% Check that all sounds have the same format
% RLB
% siz = wavread(estFile,'size');
infos_est = audioinfo(estFile);
siz_est = [infos_est.TotalSamples infos_est.NumChannels];
for j=1:J
    % RLB
    infos_src = audioinfo(srcFiles{j});
    siz_src = [infos_src.TotalSamples infos_src.NumChannels];
    if any(siz_est~=siz_src)
        fprintf(2,'Size of source file %d (%s): %d x %d\n',...
            j,srcFiles{j},siz_src);
        fprintf(2,'Size of estimate file (%s): %d x %d\n',estFile,siz_est);
        error('PEASS:BadSoundSize',...
            'Sound files must have the same size (length and number of channels).');
    end
end


fid = 1;

fprintf(fid,'\n*********************************************\n');
fprintf(fid,'Processing of:\n');
fprintf(fid,' - %s\n',estFile);
fprintf(fid,'*********************************************\n\n');


%% Auditory filter bank
fprintf('Auditory filter bank... ');
% RLB
%siz = wavread(srcFiles{1},'size');
%NChan = siz(2);
infos_src = audioinfo(srcFiles{1});
NChan = infos_src.NumChannels;

sj_gamma = cell(J,NChan);
Mmod = []; % to store coefficients and save computations
for j=1:J
    % RLB
    [sj fs] = audioread(srcFiles{j});
    if options.shadeInMs>0
        wShadeIn = hann(2*round(options.shadeInMs/1000*fs+1),'periodic');
        wShadeIn = wShadeIn(2:end/2);
        for nChan = 1:NChan
            sj(1:length(wShadeIn),nChan) = sj(1:length(wShadeIn),nChan).*wShadeIn;
        end
    end
    if options.shadeOutMs>0
        wShadeOut = hann(2*round(options.shadeOutMs/1000*fs+1),'periodic');
        wShadeOut = wShadeOut(2:end/2);
        wShadeOut = flipud(wShadeOut);
        for nChan = 1:NChan
            sj(size(sj,1)+(-length(wShadeOut)+1:0),nChan) = sj(size(sj,1)+(-length(wShadeOut)+1:0),nChan).*wShadeOut;
        end
    end
    for nChan = 1:NChan
        [sj_gamma{j,nChan}, analyzer, Mmod] =...
            myPemoAnalysisFilterBank(sj(:,nChan),fs,Mmod);
    end
end

sj_est_gamma = cell(1,NChan);
[sj fs] = audioread(estFile);
if options.shadeInMs>0
    wShadeIn = hann(2*round(options.shadeInMs/1000*fs+1),'periodic');
    wShadeIn = wShadeIn(2:end/2);
    for nChan = 1:NChan
        sj(1:length(wShadeIn),nChan) = sj(1:length(wShadeIn),nChan).*wShadeIn;
    end
end
if options.shadeOutMs>0
    wShadeOut = hann(2*round(options.shadeOutMs/1000*fs+1),'periodic');
    wShadeOut = wShadeOut(2:end/2);
    wShadeOut = flipud(wShadeOut);
    for nChan = 1:NChan
        sj(size(sj,1)+(-length(wShadeOut)+1:0),nChan) = sj(size(sj,1)+(-length(wShadeOut)+1:0),nChan).*wShadeOut;
    end
end
for nChan = 1:NChan
    [sj_est_gamma{1,nChan}, analyzer] =...
        myPemoAnalysisFilterBank(sj(:,nChan),fs,Mmod);
end

Mmod = [];

fprintf('Done\n')

%% Bandwise component extraction
fprintf('Bandwise component extraction... ');

% format conversion
s = cellA12_cellB_vecC_2_cellB_vecCA21(sj_gamma);
sEst = cellA12_cellB_vecC_2_cellB_vecCA21(sj_est_gamma);

clear sj_gamma sj_est_gamma
fRef = 1000;
TframeFRef = options.frameLength;
ThopFRef = TframeFRef/4;
[dum I] = min(abs(analyzer.center_frequencies_hz-fRef));
bwRef = analyzer.bw(I);
fsb = analyzer.fs./analyzer.Ndec;
TfilterFRef = min(options.filterLength,TframeFRef/NChan/J/3);
flens = max(3,...
    2*round((TfilterFRef*bwRef./analyzer.bw.*fsb-1)/2)'+1); % longueur impaire filtres
Lws = max(3,round(TframeFRef*bwRef./analyzer.bw.*fsb))'; % longueur trames
hops = max(1,round(ThopFRef*bwRef./analyzer.bw.*fsb))';% hop sizes

sgTrue = cell(size(s));
egTarget = cell(size(s));
egInterf = cell(size(s));
egArtif = cell(size(s));
for k=1:length(s)
    % In each band, decompose
    [sgTrue{k},egTarget{k},egInterf{k},egArtif{k}] = ...
        extractTSIA(s{k},sEst{k},flens(k),Lws(k),hops(k),...
        options);
end
fprintf('Done\n')

clear s sEst

% format conversion
s_gamma_true = cellB_vecCA21_2_cellA12_cellB_vecC(sgTrue);
s_gamma_target = cellB_vecCA21_2_cellA12_cellB_vecC(egTarget);
s_gamma_interf = cellB_vecCA21_2_cellA12_cellB_vecC(egInterf);
s_gamma_artif = cellB_vecCA21_2_cellA12_cellB_vecC(egArtif);

clear sgTrue egTarget egInterf egArtif

%% Component synthesis
fprintf('Component synthesis... ');
for nChan = 1:NChan
    [trueSynth(:,nChan), synthesizer, Mmod] = ...
        myPemoSynthesisFilterBank(s_gamma_true{1,nChan},analyzer,Mmod);
    [targetSynth(:,nChan), synthesizer, Mmod] = ...
        myPemoSynthesisFilterBank(s_gamma_target{1,nChan},analyzer,Mmod);
    [interfSynth(:,nChan), synthesizer, Mmod] = ...
        myPemoSynthesisFilterBank(s_gamma_interf{1,nChan},analyzer,Mmod);
    [artifSynth(:,nChan), synthesizer, Mmod] = ...
        myPemoSynthesisFilterBank(s_gamma_artif{1,nChan},analyzer,Mmod);
end
% RLB
%wavwrite(trueSynth,fs,outputFilenames{1,1});
%wavwrite(targetSynth,fs,outputFilenames{2,1});
%wavwrite(interfSynth,fs,outputFilenames{3,1});
%wavwrite(artifSynth,fs,outputFilenames{4,1});
audiowrite(outputFilenames{1,1},trueSynth,fs);
audiowrite(outputFilenames{2,1},targetSynth,fs);
audiowrite(outputFilenames{3,1},interfSynth,fs);
audiowrite(outputFilenames{4,1},artifSynth,fs);

clear trueSynth targetSynth interfSynth artifSynth
fprintf('Done\n')


return

%%%%%%%%%%%%%%%%%
function aux_segmentAndDecompose(srcFiles,estFile,options)
try
    % RLB
    %[siz fs] = wavread(srcFiles{1},'size');
    infos_src = audioinfo(srcFiles{1});
    siz = infos_src.TotalSamples;
    fs = infos_src.SampleRate;
    
    TCut = ceil(siz(1)/options.segmentationFactor)/fs;
    for kj=1:length(srcFiles)
        [originalCutFiles(:,kj)] = aux_cutWav(srcFiles{kj},TCut);
    end
    optionsCut = options;
    optionsCut.segmentationFactor = 1;
    optionsCut.outputFilenames = [];
    optionsCut.destDir = tempdir;
    [estimateCutFiles,Istart] = aux_cutWav(estFile,TCut);
    for kCut = 1:length(estimateCutFiles)
        optionsCut.shadeInMs = 0;
        optionsCut.shadeOutMs = 0;
        if kCut==1
            optionsCut.shadeInMs = 10;
        end
        if kCut==length(estimateCutFiles)
            optionsCut.shadeOutMs = 10;
        end
        TSIANamesCut{kCut} = extractDistortionComponents(...
            originalCutFiles(kCut,:),estimateCutFiles{kCut},optionsCut);
    end
    aux_mergeWav(estimateCutFiles,estFile,Istart,options);
    for k=1:length(estimateCutFiles(:))
        delete(estimateCutFiles{k});
    end
    %     end
catch %ME
    for k=1:length(originalCutFiles(:))
        delete(originalCutFiles{k});
    end
    for k=1:length(estimateCutFiles(:))
        delete(estimateCutFiles{k});
    end
    rethrow(lasterror);%(ME);
end
for k=1:length(originalCutFiles(:))
    delete(originalCutFiles{k});
end

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [filenames,Istart] = aux_cutWav(file,T)
% RLB
%[siz,fs] = wavread(file,'size');
infos_file = audioinfo(file);
siz = infos_file.TotalSamples;
fs = infos_file.SampleRate;
    
N = 2*round(T*fs/2);
Istart = 1:N/2:siz(1)-N/2+1;
Iend = min(Istart+N-1,siz(1));

destBase = tempname;
for kCut = 1:length(Istart)
    % RLB
    %[x,fs] = wavread(file,[Istart(kCut), Iend(kCut)]);
    %wavwrite(x,fs,[destBase '_' num2str(kCut) '.wav']);
    [x,fs] = audioread(file,[Istart(kCut), Iend(kCut)]);
    audiowrite([destBase '_' num2str(kCut) '.wav'],x,fs);
   
    filenames{kCut} = [destBase '_' num2str(kCut) '.wav'];
end
return
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function aux_mergeWav(cutFilenames,estFile,Istart,options)
% RLB
%[siz0 fs] = wavread(estFile,'size');
infos_est = audioinfo(estFile);
siz0 = infos_est.TotalSamples;
fs = infos_est.SampleRate;

components = {'true','eArtif','eTarget','eInterf'};

for kComp = 1:length(components)
    x = zeros(siz0);
    w = zeros(siz0);
    for kCut = 1:length(Istart)
        sourceFile = [cutFilenames{kCut}(1:end-4) '_' components{kComp} '.wav'];
        % RLB
        %xCut = wavread(sourceFile);
        xCut = audioread(sourceFile);
        if kComp==1 && kCut==1
            wCut = flipud(hann(size(xCut,1),'periodic'))*ones(1,siz0(2));
        end
        N = size(xCut,1);
        if Istart(kCut)+N-1>size(x,1)
            xCut = xCut(1:size(x,1)-Istart(kCut)+1,:);
            N = size(xCut,1);
        end
        x(Istart(kCut)+(0:N-1),:) = x(Istart(kCut)+(0:N-1),:) ...
            + xCut.*wCut(1:N,:);
        w(Istart(kCut)+(0:N-1),:) = w(Istart(kCut)+(0:N-1),:) ...
            + wCut(1:N,:);
    end
    I = w(:)~=0;
    x(I) = x(I)./w(I);
    
    [dum destFilename] = fileparts(estFile);
    destFilename = sprintf(...
        '%s%s_%s.wav',...
        options.destDir,destFilename,components{kComp});
    % RLB
    %wavwrite(x,fs,destFilename);
    audiowrite(destFilename,x,fs);
end


return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function y = cellA12_cellB_vecC_2_cellB_vecCA21(x)
% format conversion

[A1 A2] = size(x);
[B1 B2]= size(x{1,1});
C = cellfun('length',x{1,1});

y = arrayfun(@(n)zeros(n,A2,A1),C,'UniformOutput',false);
for a1=1:A1
    for a2=1:A2
        for b1=1:B1
            for b2=1:B2
                y{b1,b2}(:,a2,a1) = x{a1,a2}{b1,b2};
            end
        end
    end
end

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function x = cellB_vecCA21_2_cellA12_cellB_vecC(y)
% format conversion

[B1 B2]= size(y);
[dum A2 A1] = size(y{1,1});

x = cell(A1,A2);
for a1=1:A1
    for a2=1:A2
        x{a1,a2} = cell(B1,B2);
        for b1=1:B1
            for b2=1:B2
                x{a1,a2}{b1,b2} = squeeze(y{b1,b2}(:,a2,a1)).';
            end
        end
    end
end

return
